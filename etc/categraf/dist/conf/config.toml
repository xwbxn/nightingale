[global]
# whether print configs
print_configs = false

# add label(agent_hostname) to series
# "" -> auto detect hostname
# "xx" -> use specified string xx
# "$hostname" -> auto detect hostname
# "$ip" -> auto detect ip
# "$hostname-$ip" -> auto detect hostname and ip to replace the vars
hostname = ""

# will not add label(agent_hostname) if true
omit_hostname = false

# s | ms
precision = "ms"

# global collect interval
interval = 15

# input provider settings; optional: local / http
providers = ["local"]

disable_usage_report = true

[global.labels]
# region = "shanghai"
# env = "localhost"
busigroup = "{{.Busigroup}}"

[log]
# file_name is the file to write logs to
file_name = "stdout"

# options below will not be work when file_name is stdout or stderr
# max_size is the maximum size in megabytes of the log file before it gets rotated. It defaults to 100 megabytes.
max_size = 100
# max_age is the maximum number of days to retain old log files based on the timestamp encoded in their filename.  
max_age = 1
# max_backups is the maximum number of old log files to retain.  
max_backups = 1
# local_time determines if the time used for formatting the timestamps in backup files is the computer's local time.  
local_time = true
# Compress determines if the rotated log files should be compressed using gzip. 
compress = false

[writer_opt]
batch = 1000
chan_size = 1000000

[[writers]]
url = "{{.WriterUrl}}"

# Basic auth username
basic_auth_user = "{{.WriterUser}}"

# Basic auth password
basic_auth_pass = "{{.WriterPass}}"

## Optional headers
# headers = ["X-From", "categraf", "X-Xyz", "abc"]

# timeout settings, unit: ms
timeout = 5000
dial_timeout = 2500
max_idle_conns_per_host = 100

[http]
enable = {{.HttpEnable}}
address = ":9100"
print_access = false
run_mode = "release"

[ibex]
  enable = {{.IbexEnable}}
  ## ibex flush interval
  interval = "1000ms"
  ## n9e ibex server rpc address
  Servers = ["{{.IbexServer}}"]
  ## temp script dir
  metaDir = "./meta"

[http_provider]
# HttpRemoteProvider插件，通过Http请求的方式获取Categraf的配置
# 通过设置global中的provider为HttpRemoteProvider启用
# example request: GET /categraf/configs?agent=categraf&host=machine1 HTTP/1.1
# struct of response
# type httpRemoteProviderResponse struct {
#	// version is signature/md5 of current Config, server side should deal with the Version calculate
#	Version string `json:"version"`
#
#	// ConfigMap (InputName -> Config), if version is identical, server side can set Config to nil
#	Configs map[string]cfg.ConfigWithFormat `json:"configs"`
# }
# type ConfigWithFormat struct {
# 	Config string       `json:"config"`
# 	Format ConfigFormat `json:"format"`
# }
# example response:
# {
#  "version": "111",
#  "configs": {
#    "mysql": {
#      "config": "# # collect interval\n# interval = 15\n\n[[ instances ]]\naddress = \"172.33.44.55:3306\"\nusername = \"111\"\npassword = \"2222\"\nlabels = { instance = \"mysql2\"}\nextra_innodb_metrics =true",
#      "format": "toml"
#    }
#  }
#}
#
# remote url
remote_url = "http://{{.ProviderServer}}/categraf/configs"

# header settings when request config from remote
# headers = ["X-From", "categraf", "X-Xyz", "abc"]

# http basic auth config
# basic_auth_user = ""
# basic_auth_pass = ""

# http timeout in seconds
timeout = 5

# reload interval in seconds
reload_interval = 120

## Optional TLS Config
# use_tls = false
# tls_ca = "/etc/categraf/ca.pem"
# tls_cert = "/etc/categraf/cert.pem"
# tls_key = "/etc/categraf/key.pem"
## Use TLS but skip chain & host verification
# insecure_skip_verify = false