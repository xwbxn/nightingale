{"version":3,"file":"worker.f0706a63.js","sources":["../../src/components/D3Charts/src/getNearestPoints.ts","../../src/components/D3Charts/src/worker.ts"],"sourcesContent":["/*\r\n * Copyright 2022 Nightingale Team\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nimport { GetNearestPointsFnParam, Serie, SerieDataItem, NearestPoint } from './interface';\r\n\r\nfunction getMsTs(ts: number, type: string) {\r\n  return type === 'X' ? ts * 1000 : ts;\r\n}\r\n\r\nfunction ascending(a: number | Date, b: number | Date): number {\r\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\r\n}\r\n\r\nfunction pickBy<T extends object>(obj: T, predicate: (key: keyof T) => boolean) {\r\n  const newObj: any = {};\r\n  for (const key in obj) {\r\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\r\n      if (Object.prototype.toString.call(predicate) === '[object Function]' && predicate(key)) {\r\n        newObj[key] = obj[key];\r\n      }\r\n    }\r\n  }\r\n  return newObj;\r\n}\r\n\r\nfunction bisector(compare: (d: SerieDataItem, x: Date) => number) {\r\n  return {\r\n    left: (a: any[], x: any, lo?: any, hi?: any) => {\r\n      if (lo == null) lo = 0;\r\n      if (hi == null) hi = a.length;\r\n      while (lo < hi) {\r\n        const mid = lo + hi >>> 1;\r\n        if (compare(a[mid], x) < 0) lo = mid + 1;\r\n        else hi = mid;\r\n      }\r\n      return lo;\r\n    },\r\n    right: (a: any[], x: any, lo?: any, hi?: any) => {\r\n      if (lo == null) lo = 0;\r\n      if (hi == null) hi = a.length;\r\n      while (lo < hi) {\r\n        const mid = lo + hi >>> 1;\r\n        if (compare(a[mid], x) > 0) hi = mid;\r\n        else lo = mid + 1;\r\n      }\r\n      return lo;\r\n    },\r\n  };\r\n}\r\n\r\nexport default function getNearestPoints(dat: GetNearestPointsFnParam) {\r\n  const { series, x, xkey, ykey, timestamp, fillNull } = dat;\r\n  const xBisect = bisector(\r\n    (d, x) => {\r\n      return ascending(getMsTs(d[xkey], timestamp), x);\r\n    }\r\n  ).left;\r\n  const tsX = (new Date(x)).getTime();\r\n  const nearestPoints: NearestPoint[] = [];\r\n\r\n  if (Object.prototype.toString.call(series) !== '[object Array]') return [];\r\n  series.forEach((serie, i) => {\r\n    if (serie.visible === false) return;\r\n    const { name, color } = serie;\r\n    const serieWithEffective = pickBy<Serie>(serie, (key) => {\r\n      return key !== 'data';\r\n    });\r\n    let { data = [] } = serie;\r\n    if (Object.prototype.toString.call(data) !== '[object Array]') return;\r\n    data = data.filter(item => typeof item[ykey] === 'number' || typeof fillNull === 'number');\r\n\r\n    if (data.length === 0) return;\r\n\r\n    let nearestPoint: NearestPoint;\r\n    const pos = xBisect(data, x);\r\n    const smaller = data[pos - 1];\r\n    const larger = data[pos];\r\n\r\n    if (smaller && larger) {\r\n      const smallerX = getMsTs(smaller[xkey], timestamp);\r\n      const largerX = getMsTs(larger[xkey], timestamp);\r\n      let smallerY = smaller[ykey];\r\n      let largerY = larger[ykey];\r\n\r\n      if (smallerY === null && fillNull !== undefined) smallerY = fillNull;\r\n      if (largerY === null && fillNull !== undefined) largerY = fillNull;\r\n\r\n      if (tsX - smallerX < largerX - tsX) {\r\n        nearestPoint = {\r\n          ...smaller,\r\n          name,\r\n          color,\r\n          timestamp: smallerX,\r\n          value: smallerY,\r\n          serieIndex: i,\r\n          serieOptions: serieWithEffective,\r\n        };\r\n      } else {\r\n        nearestPoint = {\r\n          ...larger,\r\n          name,\r\n          color,\r\n          timestamp: largerX,\r\n          value: largerY,\r\n          serieIndex: i,\r\n          serieOptions: serieWithEffective,\r\n        };\r\n      }\r\n      nearestPoints.push(nearestPoint);\r\n    } else if (smaller) {\r\n      const smallerX = getMsTs(smaller[xkey], timestamp);\r\n      let smallerY = smaller[ykey];\r\n      if (smallerY === null && fillNull !== undefined) smallerY = fillNull;\r\n      nearestPoint = {\r\n        ...smaller,\r\n        name,\r\n        color,\r\n        timestamp: smallerX,\r\n        value: smallerY,\r\n        serieIndex: i,\r\n        serieOptions: serieWithEffective,\r\n      };\r\n      nearestPoints.push(nearestPoint);\r\n    } else if (larger) {\r\n      const largerX = getMsTs(larger[xkey], timestamp);\r\n      let largerY = larger[ykey];\r\n      if (largerY === null && fillNull !== undefined) largerY = fillNull;\r\n      nearestPoint = {\r\n        ...larger,\r\n        name,\r\n        color,\r\n        timestamp: largerX,\r\n        value: largerY,\r\n        serieIndex: i,\r\n        serieOptions: serieWithEffective,\r\n      };\r\n      nearestPoints.push(nearestPoint);\r\n    }\r\n  });\r\n\r\n  return nearestPoints;\r\n}\r\n","/*\r\n * Copyright 2022 Nightingale Team\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n *\r\n */\r\nimport getNearestPoints from './getNearestPoints';\r\nimport { Serie } from './interface';\r\n\r\ntype CacheType = {\r\n  [index: string]: string;\r\n};\r\ntype SeriesType = {\r\n  [index: string]: Serie[];\r\n};\r\n\r\nconst cache: CacheType = {};\r\nconst series: SeriesType = {};\r\nconst ctx: Worker = self as any;\r\n\r\nctx.addEventListener('message', (event) => {\r\n  const { data } = event;\r\n\r\n  if (data.id) {\r\n    if (!cache[data.id] || !data.flag) {\r\n      cache[data.id] = data.str;\r\n      series[data.id] = JSON.parse(data.str);\r\n    }\r\n  }\r\n\r\n  const nearestPoints = getNearestPoints({\r\n    x: data.x,\r\n    xkey: data.xkey,\r\n    ykey: data.ykey,\r\n    y0key: data.y0key,\r\n    timestamp: data.timestamp,\r\n    series: series[data.id],\r\n    fillNull: data.fillNull,\r\n  });\r\n\r\n  ctx.postMessage(nearestPoints); // TODO: targetOrigin\r\n});\r\n\r\nexport default ctx;\r\n"],"names":["ts","type","dat","series","x","xkey","ykey","timestamp","fillNull","xBisect","compare","d","x2","a","getMsTs","b","NaN","left","lo","hi","length","mid","right","tsX","Date","getTime","nearestPoints","Object","prototype","toString","call","series2","forEach","serie","i","visible","name","color","serieWithEffective","obj","predicate","newObj","key","hasOwnProperty","pickBy","nearestPoint","data","filter","item","pos","smaller","larger","smallerX","largerX","smallerY","largerY","__spreadProps","value","serieIndex","serieOptions","push","cache","ctx","self","addEventListener","event","id","flag","str","JSON","parse","getNearestPoints","y0key","postMessage"],"mappings":"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"}